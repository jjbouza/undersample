"""
Description: Some tools for generating variable density sampling masks, mostly following the SparseMRI MATLAB package by Lustig et al.
Author: Jose J Bouza
"""


import numpy as np
import matplotlib.pyplot as plt # for mask plotting

def gen_pdf(size, p, pctg, dims=3, radius=0.1):
    """
    Generate a 3D or 2D power density PDF, and then translate it to generate
    only a specific pctg of samples...
    
    size - side length of pdf support.
    pctg - sampling factor between 0 and 1
    radius - fully sampled center radius
    """

    # check some basic conditions
    assert(dims == 3 or dims == 2)
    assert(pctg > 0 and pctg < 1)
    assert(size > 0)
    assert(radius >= 0)

    PCTG = np.floor(pctg*(size**dims))

    # generate grid samples
    side_samples = np.linspace(-1, 1, num=size)

    if dims == 3:
        grid_samples = np.array([[[(x,y,z) for x in side_samples] for y in side_samples] for z in side_samples])
    elif dims == 2:
        grid_samples = np.array([[(x,y) for x in side_samples] for y in side_samples])

    # generate distance from origin grid
    r = np.sqrt(np.sum(np.power(grid_samples, 2), axis=-1))
    r_norm = r/np.max(r)

    #generate pdf
    pdf_o = np.power((1-r_norm), p)
    pdf_o[r <= radius] = 1

    if np.floor(np.sum(pdf_o)) > PCTG:
        print("ERROR: Infeasible undersampling rate given p, radius parameters.")
        return None

    #bisection method to get pctg to desired value by adding translation to pdf function:
    minval = 0
    maxval = 1
    while True:
        val = (minval+maxval)/2
        pdf = pdf_o + val
        pdf[pdf > 1] = 1
        pdf[r <= radius] = 1

        N = np.floor(np.sum(pdf))

        if N > PCTG:
            maxval = val
        elif N < PCTG:
            minval = val
        else:
            break

    return pdf

def gen_sampling_mask(pdf, iterations=1000, tol=1):
    """
    Use a Monte-Carlo scheme to generate a sampling pattern from the given pdf.
    Generates many masks and chooses the one with the minimal peak interference.

    pdf - pdf function generated by e.g. gen_pdf
    iterations - number of masks to try to minimize peak interference over
    tol - number of samples will sum(pdf) +- tol
    """
    goal_sum = np.sum(pdf)
    minInterference = np.inf
    minInterferenceSample = None

    for i in range(iterations):
        # generate mask:
        generated_mask = np.zeros_like(pdf)
        while np.abs(np.sum(generated_mask) - goal_sum) > tol:
            generated_mask = (np.random.rand(*pdf.shape) < pdf).astype(np.int)

        generated_mask_spatial = np.fft.ifft(generated_mask/pdf)
        peak_interference = np.max(generated_mask_spatial)

        if peak_interference < minInterference:
            minInterference = peak_interference
            minInterferenceSample = generated_mask

    return minInterferenceSample

def generate_power_density_mask(pctg, radius, dims, size, p):
    """
    Generate a power density sampling mask.
    
    size - side length of pdf support.
    pctg - sampling factor between 0 and 1
    radius - fully sampled center radius
    """

    assert(dims == 3 or dims == 2)
    pdf = gen_pdf(size, p, pctg, dims, radius)
    sampling_mask = gen_sampling_mask(pdf)

    return sampling_mask


# generates two sampling masks, one in k and one in q and then joins them
def generate_kq_power_density_mask(pctg, radius, dimsk, sizek, sizeq, p):
    kmask = generate_power_density_mask(np.sqrt(pctg), radius, dimsk, sizek, p)
    qmask = generate_power_density_mask(np.sqrt(pctg), radius, 3, sizeq, p)

    kq_mask = np.resize(kmask, list(kmask.shape)+[sizeq for _ in range(3)])
    zero_arr = np.zeros_like(qmask)

    kq_mask[kmask == 1] = qmask
    kq_mask[kmask == 0] = zero_arr
    return kq_mask

